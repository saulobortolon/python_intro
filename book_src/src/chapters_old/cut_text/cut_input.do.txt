
======= Summary of Chapter 4 =======

=== Reading input from the user. ===
We have introduced two main ways to let users give input data to our programs. We can use `input` to let the program
stop and ask for input from the user:
!bc pycod-t
var = input('Give value: ')   # var is string!

# if var needs to be a number:
var = float(var)
# or in general:
var = eval(var)
!ec

Alternatively, input data can be provided as command-line arguments, and accessed through the list `sys.argv`:
!bc pycod-t
import sys
parameter1 = eval(sys.argv[1])
parameter3 = sys.argv[3]          # string is ok
parameter2 = eval(sys.argv[2])
!ec
Recall that `sys.argv[0]` is the program name, so the remaining list `sys.argv[1:]` contains the command-line arguments.

=== Using  `eval` and `exec` to process input. ===
The "magic" functions `eval` and `exec` let us run Python code in string variables as if the code was typed directly
into the program. For evaluating expressions, we use `eval`:
!bc pyshell
>>> x = 20
>>> r = eval('x + 1.1')
>>> r
21.1
>>> type(r)
<type 'float'>
!ec
While `exec` is used for running strings with complete Python code, one or multiple lines:
!bc pycod-t

exec(f"""
def f(x):
    return {sys.argv[1]}
""")
!ec


!split
=== Try-except blocks provide a flexible way to handle errors. ===
The structure of a try-except block looks as follows:
!bc pycod-t
try:
    <statements>
except ExceptionType1:
    <provide a remedy for ExceptionType1 errors>
except ExceptionType2, ExceptionType3, ExceptionType4:
    <provide a remedy for three other types of errors>
except:
    <provide a remedy for any other errors>
...
!ec
The general idea is that we put whatever code we suspect could go wrong inside the try block, and write code to
handle errors of different types inside the individual except-blocks. We have seen that we can also raise
Exceptions ourselves, for instance if we encounter non-physical or otherwise wrong input data:
!bc pycod-t
if z < 0:
    raise ValueError(
        f'z={z} is negative - cannot do log(z)')
!ec

=== Reading from and writing to files. ===
Arguably, the most useful and relevant way to get data into a program is to read from files. Opening files for
reading or writing is done with the function `open`:
!bc pycod-t
infile  = open(filename, 'r')   # read
outfile = open(filename, 'w')   # write
outfile = open(filename, 'a')   # append
!ec

Once it is opened, we can read the contents of a file in many ways:
!bc pycod-t
# Reading
line    = infile.readline()   # read the next line
filestr = infile.read()       # read rest of file into string
lines   = infile.readlines()  # read rest of file into list
for line in infile:           # read rest of file line by line
!ec
The last option is often the most convenient. We step through the file line by line using a for-loop, processing one line
for each pass of the loop. For processing lines from files, or string variables in general, the method `split` is
extremely useful. By default, `split` will split the words separated by spaces in a text string into a list of words:
!bc pycod-t
line1 = "August 16.9"
words = line1.split()
month = words[0]
temp = float(words[1])

line2 = "20.0,45,98"
numbers = line2.split(',')
numbers = [float(x) for x in numbers]
!ec

Writing to files is done in much the same way as reading. It is important to close the file after you are done writing:
!bc pycod-t
# Writing
outfile.write(s)   # add \n if you need it

# Closing
infile.close()
outfile.close()
!ec
